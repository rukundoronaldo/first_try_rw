"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findUpAsync = exports.findAsync = exports.findUpSync = exports.findSync = void 0;
/* eslint-disable @typescript-eslint/no-inferrable-types */
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const readdirAsync = util_1.promisify(fs_1.default.readdir);
const realpathAsync = util_1.promisify(fs_1.default.realpath);
const statAsync = util_1.promisify(fs_1.default.stat);
const readdirSync = fs_1.default.readdirSync;
const realpathSync = fs_1.default.realpathSync;
const statSync = fs_1.default.statSync;
/**
 * Transform a dirent to a file type
 * @param dirent
 * @returns
 */
function direntToType(dirent) {
    return dirent.isFile()
        ? 'f'
        : dirent.isDirectory()
            ? 'd'
            : dirent.isSymbolicLink()
                ? 'l'
                : undefined;
}
/**
 * Is true if at least one matched
 * @param string to match aigainst
 * @param regexs to be matched with
 * @returns
 */
function isMatched(string, regexs) {
    for (const regex of regexs) {
        if (typeof regex === 'string') {
            if (string.includes(regex)) {
                return true;
            }
        }
        else if (regex.exec(string)) {
            return true;
        }
    }
    return false;
}
/**
 * Find paths that match a set of regexes
 * @param root to start from
 * @param match to match against
 * @param types to select files, folders, links
 * @param deep to recurse in the directory tree
 * @param limit to limit the results
 * @param handler to further filter results
 * @param found to add to already found
 * @param seen to add to already seen
 * @returns found paths (symlinks preserved)
 */
function findSync(root, match, types = ['f', 'd', 'l'], deep = [], limit = Infinity, handler = () => true, found = [], seen = {}) {
    try {
        const realRoot = realpathSync(root);
        // we make sure not to loop infinitely
        if (seen[realRoot]) {
            return found;
        }
        // we stop if we found enough results
        if (limit - found.length <= 0) {
            return found;
        }
        // we check that the root is a directory
        if (direntToType(statSync(realRoot)) !== 'd') {
            return found;
        }
        // we list the items in the current root
        const items = readdirSync(root, { withFileTypes: true });
        //seen[realRoot] = true
        for (const item of items) {
            // we get the file info for each item
            const itemName = item.name;
            const itemType = direntToType(item);
            const itemPath = path_1.default.join(root, item.name);
            // if the item is one of the selected
            if (itemType && types.includes(itemType)) {
                // if the path of an item has matched
                if (isMatched(itemPath, match)) {
                    const value = handler(root, itemName, itemType);
                    // if we changed the path value
                    if (typeof value === 'string') {
                        found.push(value);
                    }
                    // if we kept the default path
                    else if (value === true) {
                        found.push(itemPath);
                    }
                }
            }
            if (deep.includes(itemType)) {
                // dive within the directory tree
                // we recurse and continue mutating `found`
                findSync(itemPath, match, types, deep, limit, handler, found, seen);
            }
        }
    }
    catch (_a) { }
    return found;
}
exports.findSync = findSync;
/**
 * Like `findSync` but moves to the parent folder if nothing is found
 * @param root to start from
 * @param match to match against
 * @param types to select files, folders, links
 * @param deep to recurse in the directory tree
 * @param limit to limit the results
 * @param filter to further filter results
 * @param found to add to already found
 * @param seen to add to already seen
 * @returns found paths (symlinks preserved)
 */
function findUpSync(root, match, types = ['f', 'd', 'l'], deep = [], limit = Infinity, handler = () => true, found = [], seen = {}) {
    // stop if we cannot go any higher than this root
    if (path_1.default.resolve(root) === path_1.default.resolve(root, '..')) {
        return found;
    }
    findSync(root, match, types, deep, limit, handler, found, seen);
    if (found.length === 0) {
        const parent = path_1.default.join(root, '..');
        findUpSync(parent, match, types, deep, limit, handler, found, seen);
    }
    return found;
}
exports.findUpSync = findUpSync;
/**
 * Find paths that match a set of regexes
 * @param root to start from
 * @param match to match against
 * @param types to select files, folders, links
 * @param deep to recurse in the directory tree
 * @param limit to limit the results
 * @param filter to further filter results
 * @param found to add to already found
 * @param seen to add to already seen
 * @returns found paths (symlinks preserved)
 */
async function findAsync(root, match, types = ['f', 'd', 'l'], deep = [], limit = Infinity, handler = () => true, found = [], seen = {}) {
    try {
        const realRoot = await realpathAsync(root);
        // we make sure not to loop infinitely
        if (seen[realRoot]) {
            return found;
        }
        // we stop if we found enough results
        if (limit - found.length <= 0) {
            return found;
        }
        // we check that the root is a directory
        if (direntToType(await statAsync(realRoot)) !== 'd') {
            return found;
        }
        // we list the items in the current root
        const items = await readdirAsync(root, { withFileTypes: true });
        seen[realRoot] = true;
        for (const item of items) {
            // we get the file info for each item
            const itemName = item.name;
            const itemType = direntToType(item);
            const itemPath = path_1.default.join(root, item.name);
            // if the ietm is one of the selected
            if (itemType && types.includes(itemType)) {
                // if the path of an item has matched
                if (isMatched(itemPath, match)) {
                    const value = handler(root, itemName, itemType);
                    // if we changed the path value
                    if (typeof value === 'string') {
                        found.push(value);
                    }
                    // if we kept the default path
                    else if (value === true) {
                        found.push(itemPath);
                    }
                }
            }
            // dive within the directory tree
            if (deep.includes(itemType)) {
                // we recurse and continue mutating `found`
                await findAsync(itemPath, match, types, deep, limit, handler, found, seen);
            }
        }
    }
    catch (_a) { }
    return found;
}
exports.findAsync = findAsync;
/**
 * Like `findSync` but moves to the parent folder if nothing is found
 * @param root to start from
 * @param match to match against
 * @param types to select files, folders, links
 * @param deep to recurse in the directory tree
 * @param limit to limit the results
 * @param filter to further filter results
 * @param found to add to already found
 * @param seen to add to already seen
 * @returns found paths (symlinks preserved)
 */
async function findUpAsync(root, match, types = ['f', 'd', 'l'], deep = [], limit = Infinity, handler = () => true, found = [], seen = {}) {
    // stop if we cannot go any higher than this root
    if (path_1.default.resolve(root) === path_1.default.resolve(root, '..')) {
        return found;
    }
    await findAsync(root, match, types, deep, limit, handler, found, seen);
    if (found.length === 0) {
        const parent = path_1.default.join(root, '..');
        await findUpAsync(parent, match, types, deep, limit, handler, found, seen);
    }
    return found;
}
exports.findUpAsync = findUpAsync;
//# sourceMappingURL=find.js.map