"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConfig = exports.GetConfigError = void 0;
const debug_1 = __importDefault(require("@prisma/debug"));
const fetch_engine_1 = require("@prisma/fetch-engine");
const chalk_1 = __importDefault(require("chalk"));
const execa_1 = __importDefault(require("execa"));
const fs_1 = __importDefault(require("fs"));
const temp_write_1 = __importDefault(require("temp-write"));
const util_1 = require("util");
const resolveBinary_1 = require("../resolveBinary");
const debug = debug_1.default('prisma:getConfig');
const unlink = util_1.promisify(fs_1.default.unlink);
const MAX_BUFFER = 1000000000;
class GetConfigError extends Error {
    constructor(message) {
        super(chalk_1.default.redBright.bold('Get config: ') + message);
    }
}
exports.GetConfigError = GetConfigError;
// TODO add error handling functions
async function getConfig(options) {
    var _a, _b, _c;
    const useNapi = process.env.PRISMA_FORCE_NAPI === 'true';
    let data;
    if (useNapi) {
        data = await getConfigNAPI(options);
    }
    else {
        data = await getConfigBinary(options);
    }
    if (!data)
        throw new GetConfigError(`Failed to return any data`);
    if (((_c = (_b = (_a = data.datasources) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.provider) === null || _c === void 0 ? void 0 : _c[0]) === 'sqlite' &&
        data.generators.some((g) => g.previewFeatures.includes('createMany'))) {
        const message = `Database provider "sqlite" and the preview feature "createMany" can't be used at the same time.
  Please either remove the "createMany" feature flag or use any other database type that Prisma supports: postgres, mysql or sqlserver.`;
        throw new GetConfigError(message);
    }
    return data;
}
exports.getConfig = getConfig;
async function getConfigNAPI(options) {
    var _a;
    let data;
    const queryEnginePath = await resolveBinary_1.resolveBinary(fetch_engine_1.EngineTypes.libqueryEngineNapi, options.prismaPath);
    debug(`Using N-API Query Engine at: ${queryEnginePath}`);
    try {
        const NApiQueryEngine = require(queryEnginePath);
        data = await NApiQueryEngine.getConfig({
            datamodel: options.datamodel,
            datasourceOverrides: {},
            ignoreEnvVarErrors: (_a = options.ignoreEnvVarErrors) !== null && _a !== void 0 ? _a : false,
        });
    }
    catch (e) {
        let error;
        try {
            error = JSON.parse(e.message);
        }
        catch (_b) {
            throw e;
        }
        let message;
        if (error.error_code === 'P1012') {
            message =
                chalk_1.default.redBright(`Schema Parsing ${error.error_code}\n\n`) +
                    error.message +
                    '\n';
        }
        else {
            message = chalk_1.default.redBright(`${error.error_code}\n\n`) + error;
        }
        throw new GetConfigError(message);
    }
    return data;
}
async function getConfigBinary(options) {
    let data;
    const queryEnginePath = await resolveBinary_1.resolveBinary(fetch_engine_1.EngineTypes.queryEngine, options.prismaPath);
    debug(`Using Query Engine Binary at: ${queryEnginePath}`);
    try {
        let tempDatamodelPath = options.datamodelPath;
        if (!tempDatamodelPath) {
            try {
                tempDatamodelPath = await temp_write_1.default(options.datamodel);
            }
            catch (err) {
                throw new GetConfigError('Unable to write temp data model path');
            }
        }
        const engineArgs = [];
        const args = options.ignoreEnvVarErrors ? ['--ignoreEnvVarErrors'] : [];
        const result = await execa_1.default(queryEnginePath, [...engineArgs, 'cli', 'get-config', ...args], {
            cwd: options.cwd,
            env: {
                PRISMA_DML_PATH: tempDatamodelPath,
                RUST_BACKTRACE: '1',
            },
            maxBuffer: MAX_BUFFER,
        });
        if (!options.datamodelPath) {
            await unlink(tempDatamodelPath);
        }
        data = JSON.parse(result.stdout);
    }
    catch (e) {
        if (e.stderr || e.stdout) {
            const error = e.stderr ? e.stderr : e.stout;
            let jsonError, message;
            try {
                jsonError = JSON.parse(error);
                message = `${chalk_1.default.redBright(jsonError.message)}\n`;
                if (jsonError.error_code) {
                    if (jsonError.error_code === 'P1012') {
                        message =
                            chalk_1.default.redBright(`Schema Parsing ${jsonError.error_code}\n\n`) +
                                message;
                    }
                    else {
                        message = chalk_1.default.redBright(`${jsonError.error_code}\n\n`) + message;
                    }
                }
            }
            catch (e) {
                // if JSON parse / pretty handling fails, fallback to simple printing
                throw new GetConfigError(error);
            }
            throw new GetConfigError(message);
        }
        throw new GetConfigError(e);
    }
    return data;
}
//# sourceMappingURL=getConfig.js.map