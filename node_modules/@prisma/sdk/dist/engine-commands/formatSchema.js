"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatSchema = void 0;
const debug_1 = __importDefault(require("@prisma/debug"));
const fetch_engine_1 = require("@prisma/fetch-engine");
const execa_1 = __importDefault(require("execa"));
const fs_1 = __importDefault(require("fs"));
const resolveBinary_1 = require("../resolveBinary");
const debug = debug_1.default('prisma:formatSchema');
const MAX_BUFFER = 1000000000;
async function formatSchema({ schemaPath, schema, }) {
    if (!schema && !schemaPath) {
        throw new Error(`Parameter schema or schemaPath must be passed.`);
    }
    const prismaFmtPath = await resolveBinary_1.resolveBinary(fetch_engine_1.EngineTypes.prismaFmt);
    const showColors = !process.env.NO_COLOR && process.stdout.isTTY;
    const options = {
        env: {
            RUST_BACKTRACE: '1',
            ...(showColors ? { CLICOLOR_FORCE: '1' } : {}),
        },
        maxBuffer: MAX_BUFFER,
    };
    let result;
    if (schemaPath) {
        if (!fs_1.default.existsSync(schemaPath)) {
            throw new Error(`Schema at ${schemaPath} does not exist.`);
        }
        result = await execa_1.default(prismaFmtPath, ['format', '-i', schemaPath], options);
    }
    else if (schema) {
        result = await execa_1.default(prismaFmtPath, ['format'], {
            ...options,
            input: schema,
        });
    }
    return result.stdout;
}
exports.formatSchema = formatSchema;
//# sourceMappingURL=formatSchema.js.map