"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDMMF = void 0;
const debug_1 = __importDefault(require("@prisma/debug"));
const fetch_engine_1 = require("@prisma/fetch-engine");
const chalk_1 = __importDefault(require("chalk"));
const execa_1 = __importDefault(require("execa"));
const fs_1 = __importDefault(require("fs"));
const temp_write_1 = __importDefault(require("temp-write"));
const util_1 = require("util");
const resolveBinary_1 = require("../resolveBinary");
const debug = debug_1.default('prisma:getDMMF');
const unlink = util_1.promisify(fs_1.default.unlink);
const MAX_BUFFER = 1000000000;
// TODO add error handling functions
async function getDMMF(options) {
    warnOnDeprecatedFeatureFlag(options.previewFeatures);
    const useNapi = process.env.PRISMA_FORCE_NAPI === 'true';
    let dmmf;
    if (useNapi) {
        dmmf = await getDmmfNapi(options);
    }
    else {
        dmmf = await getDmmfBinary(options);
    }
    return dmmf;
}
exports.getDMMF = getDMMF;
async function getDmmfNapi(options) {
    var _a;
    const queryEnginePath = await resolveBinary_1.resolveBinary(fetch_engine_1.EngineTypes.libqueryEngineNapi, options.prismaPath);
    debug(`Using N-API Query Engine at: ${queryEnginePath}`);
    const NApiQueryEngine = require(queryEnginePath);
    const datamodel = (_a = options.datamodel) !== null && _a !== void 0 ? _a : fs_1.default.readFileSync(options.datamodelPath, 'utf-8');
    let dmmf;
    try {
        dmmf = JSON.parse(await NApiQueryEngine.dmmf(datamodel));
    }
    catch (e) {
        const error = JSON.parse(e.message);
        const message = addMissingOpenSSLInfo(error.message);
        throw new Error(chalk_1.default.redBright.bold('Schema parsing\n') + message);
    }
    return dmmf;
}
async function getDmmfBinary(options) {
    let result;
    const queryEnginePath = await resolveBinary_1.resolveBinary(fetch_engine_1.EngineTypes.queryEngine, options.prismaPath);
    debug(`Using Query Engine Binary at: ${queryEnginePath}`);
    try {
        let tempDatamodelPath = options.datamodelPath;
        if (!tempDatamodelPath) {
            try {
                tempDatamodelPath = await temp_write_1.default(options.datamodel);
            }
            catch (err) {
                throw new Error(chalk_1.default.redBright.bold('Get DMMF ') +
                    'unable to write temp data model path');
            }
        }
        const execaOptions = {
            cwd: options.cwd,
            env: {
                PRISMA_DML_PATH: tempDatamodelPath,
                RUST_BACKTRACE: '1',
                ...(process.env.NO_COLOR ? {} : { CLICOLOR_FORCE: '1' }),
            },
            maxBuffer: MAX_BUFFER,
        };
        const args = ['--enable-raw-queries', 'cli', 'dmmf'];
        result = await execa_1.default(queryEnginePath, args, execaOptions);
        if (!options.datamodelPath) {
            await unlink(tempDatamodelPath);
        }
        if (result.stdout.includes('Please wait until the') &&
            options.retry &&
            options.retry > 0) {
            debug('Retrying after "Please wait until"');
            await new Promise((r) => setTimeout(r, 5000));
            return getDMMF({
                ...options,
                retry: options.retry - 1,
            });
        }
        // necessary, as sometimes the query engine prints some other stuff
        const firstCurly = result.stdout.indexOf('{');
        const stdout = result.stdout.slice(firstCurly);
        return JSON.parse(stdout);
    }
    catch (e) {
        debug('getDMMF failed', e);
        // If this unlikely event happens, try it at least once more
        if (e.message.includes('Command failed with exit code 26 (ETXTBSY)') &&
            options.retry &&
            options.retry > 0) {
            await new Promise((resolve) => setTimeout(resolve, 500));
            debug('Retrying after ETXTBSY');
            return getDMMF({
                ...options,
                retry: options.retry - 1,
            });
        }
        const output = e.stderr || e.stdout;
        if (output) {
            let json;
            try {
                json = JSON.parse(output);
            }
            catch (e) {
                //
            }
            let message = (json && json.message) || output;
            message = addMissingOpenSSLInfo(message);
            throw new Error(chalk_1.default.redBright.bold('Schema parsing\n') + message);
        }
        if (e.message.includes('in JSON at position')) {
            throw new Error(`Problem while parsing the query engine response at ${queryEnginePath}. ${result === null || result === void 0 ? void 0 : result.stdout}\n${e.stack}`);
        }
        throw new Error(e);
    }
}
function addMissingOpenSSLInfo(message) {
    if (message.includes('debian-openssl-1.1.x: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory') ||
        message.includes('debian-openssl-1.0.x: error while loading shared libraries: libssl.so.1.0.0: cannot open shared object file: No such file or directory')) {
        message += `\n${chalk_1.default.green(`Your linux installation misses the openssl package. You can install it like so:\n`)}${chalk_1.default.green.bold('apt-get -qy update && apt-get -qy install openssl')}`;
    }
    return message;
}
function warnOnDeprecatedFeatureFlag(previewFeatures) {
    const getMessage = (flag) => `${chalk_1.default.blueBright('info')} The preview flag "${flag}" is not needed anymore, please remove it from your schema.prisma`;
    const removedFeatureFlagMap = {
        insensitiveFilters: getMessage('insensitiveFilters'),
        atomicNumberOperations: getMessage('atomicNumberOperations'),
        connectOrCreate: getMessage('connectOrCreate'),
        transaction: getMessage('transaction'),
        transactionApi: getMessage('transactionApi'),
        uncheckedScalarInputs: getMessage('uncheckedScalarInputs'),
        nativeTypes: getMessage('nativeTypes'),
        createMany: getMessage('createMany'),
        groupBy: getMessage('groupBy'),
    };
    previewFeatures === null || previewFeatures === void 0 ? void 0 : previewFeatures.forEach((f) => {
        const removedMessage = removedFeatureFlagMap[f];
        if (removedMessage && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
            console.warn(removedMessage);
        }
    });
}
//# sourceMappingURL=getDmmf.js.map