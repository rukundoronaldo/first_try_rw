"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.BeforeResolverSpec = exports.MissingBeforeResolverError = exports.InsecureServiceError = void 0;

var _replaceAll = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/replace-all"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));

var _flat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/flat"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/array/is-array"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));

// Thrown if resolver function has no explicit `apply()` or `skip()`
// which includes it
const InsecureServiceError = class extends Error {
  constructor(resolverName) {
    super(`Service call not authorized. If you really want to allow access, add \`rules.skip({ only: ['${resolverName}'] })\` to your beforeResolver()`);
    this.name = 'InsecureServiceError';
  }

}; // Thrown if service has no `beforeResolver()` defined

exports.InsecureServiceError = InsecureServiceError;
const MissingBeforeResolverError = class extends Error {
  constructor(servicePath) {
    super(`Must define a \`beforeResolver()\` in ${(0, _replaceAll.default)(servicePath).call(servicePath, '_', '/')}`);
    this.name = 'MissingBeforeResolver';
  }

};
exports.MissingBeforeResolverError = MissingBeforeResolverError;
const BeforeResolverSpec = class BeforeResolverSpec {
  constructor(serviceNames) {
    this.befores = void 0;
    this.befores = {};
    (0, _forEach.default)(serviceNames).call(serviceNames, name => this._initValidators(name));
  }

  add(functions, options) {
    this._forEachService(name => {
      if (this._shouldApplyValidator(name, options)) {
        var _context;

        // If currently skippable, reset back to state that lets us add validators
        if (this.befores[name].skippable) {
          this._initValidators(name);
        }

        this.befores[name].validators = [...this.befores[name].validators, // typecast because it could be bool
        ...(0, _flat.default)(_context = [functions]).call(_context)];
      }
    });
  }

  skip(...args) {
    const {
      skipValidators,
      options,
      applyToAll
    } = this._parseSkipArgs(args);

    this._forEachService(name => {
      const validators = this.befores[name].validators;

      if (this._shouldSkipValidator(name, options)) {
        if (skipValidators.length > 0) {
          this.befores[name].validators = (0, _filter.default)(validators).call(validators, func => !(0, _includes.default)(skipValidators).call(skipValidators, func));
        } else if (applyToAll) {
          this._markServiceSkippable(name);
        } // if we just removed every validator then we're technically skipping


        if (this.befores[name].validators.length === 0) {
          this._markServiceSkippable(name);
        }
      }
    });
  }

  verify(name, args) {
    if (this._canSkipService(name)) {
      return [];
    } else if (this._isInsecureService(name)) {
      throw new InsecureServiceError(name);
    } else {
      return this._invokeValidators(name, args);
    }
  } // Initializes a service as having validators to apply, but none
  // defined yet, and definitely not skippable


  _initValidators(name) {
    this.befores[name] = {
      validators: [],
      skippable: false
    };
  }

  _shouldApplyValidator(name, options) {
    var _context2, _context3;

    return !options || (options === null || options === void 0 ? void 0 : options.only) && (0, _includes.default)(_context2 = options.only).call(_context2, name) || (options === null || options === void 0 ? void 0 : options.except) && !(0, _includes.default)(_context3 = options.except).call(_context3, name);
  }

  _shouldSkipValidator(name, options) {
    var _context4, _context5;

    return !options || options.only && (0, _includes.default)(_context4 = options.only).call(_context4, name) || options.except && !(0, _includes.default)(_context5 = options.except).call(_context5, name);
  }

  _parseSkipArgs([functionsOrOptions, opts]) {
    let skipValidators;
    let options;
    let applyToAll = false; // covers the case where no functions are passed, which means skip ALL

    if (this._isOptions(functionsOrOptions)) {
      // Options supplied in first param
      applyToAll = true;
      skipValidators = [];
      options = functionsOrOptions;
    } else {
      var _context6;

      // Rule functions supplied in first param (and maybe options in second)
      skipValidators = (0, _flat.default)(_context6 = [functionsOrOptions]).call(_context6);
      options = opts;
    }

    return {
      skipValidators,
      options,
      applyToAll
    };
  }

  _isOptions(functionsOrOptions) {
    return typeof functionsOrOptions === 'undefined' || typeof functionsOrOptions === 'object' && !(0, _isArray.default)(functionsOrOptions);
  } // marks a service as having no needed before functions to apply


  _markServiceSkippable(name) {
    this.befores[name].validators = [];
    this.befores[name].skippable = true;
  }

  _canSkipService(name) {
    return this.befores[name].skippable === true;
  }

  _isInsecureService(name) {
    const rules = this.befores[name];
    return rules.validators.length === 0 && !rules.skippable;
  } // Returns an array of the results of every validation function being run.
  // We don't do anything with this list currently, but maybe we can pass it
  // through to the service at some point so the user can do something with it?


  _invokeValidators(name, args) {
    const validators = this.befores[name].validators;
    return (0, _map.default)(validators).call(validators, rule => {
      var _context7;

      return rule.apply(this, [name, ...(0, _flat.default)(_context7 = [args]).call(_context7)]);
    });
  }

  _forEachService(iterator) {
    var _context8;

    return (0, _forEach.default)(_context8 = (0, _keys.default)(this.befores)).call(_context8, iterator);
  }

};
exports.BeforeResolverSpec = BeforeResolverSpec;